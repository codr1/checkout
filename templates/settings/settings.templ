package settings

import (
	"fmt"
	"strings"
	"checkout/config"
)

// SettingsPage represents the settings modal content
templ SettingsPage() {
	<div class="settings-modal-container">
		<!-- Fixed Header -->
		<div class="settings-modal-header">
			<div class="settings-header-content">
				<h3>Settings</h3>
				<button type="button" class="modal-close-btn" hx-post="/close-modal" hx-swap="none">
					<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
						<line x1="18" y1="6" x2="6" y2="18"></line>
						<line x1="6" y1="6" x2="18" y2="18"></line>
					</svg>
				</button>
			</div>
			<div class="search-container">
				<form hx-get="/api/settings/search" hx-target="#settings-content" hx-trigger="submit, keyup delay:500ms from:input">
					<div class="search-input-wrapper">
						<svg class="search-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
							<circle cx="11" cy="11" r="8"></circle>
							<path d="m21 21-4.35-4.35"></path>
						</svg>
						<input 
							type="text" 
							id="settings-search" 
							name="q"
							placeholder="Search settings..." 
						/>
						<button type="button" class="clear-search" onclick="clearSearch()" style="display: none;">
							<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
								<line x1="18" y1="6" x2="6" y2="18"></line>
								<line x1="6" y1="6" x2="18" y2="18"></line>
							</svg>
						</button>
					</div>
				</form>
			</div>
		</div>

		<!-- Scrollable Content -->
		<div class="settings-modal-body" id="settings-content">
			@SettingsSections()
		</div>

		<!-- Fixed Footer -->
		<div class="settings-modal-footer">
			<button type="button" class="cancel-btn" hx-post="/close-modal" hx-swap="none">Close</button>
		</div>
	</div>

	<script>
		function clearSearch() {
			const searchInput = document.getElementById('settings-search');
			const clearButton = document.querySelector('.clear-search');
			searchInput.value = '';
			clearButton.style.display = 'none';
			// Trigger HTMX to show all settings
			htmx.trigger(searchInput, 'keyup');
		}

		// Show/hide clear button based on input content
		document.addEventListener('DOMContentLoaded', function() {
			const searchInput = document.getElementById('settings-search');
			if (searchInput) {
				searchInput.addEventListener('input', function(e) {
					const clearButton = document.querySelector('.clear-search');
					if (e.target.value.length > 0) {
						clearButton.style.display = 'flex';
					} else {
						clearButton.style.display = 'none';
					}
				});
			}
		});
	</script>
}

// SettingsSections renders all settings sections
templ SettingsSections() {
	<div class="settings-sections">
		for sectionName, sectionTitle := range getSectionTitles() {
			@SettingsSection(sectionName, sectionTitle)
		}
	</div>
}

// FilteredSettingsSections renders settings sections filtered by search query
templ FilteredSettingsSections(query string) {
	<div class="settings-sections">
		for sectionName, sectionTitle := range getSectionTitles() {
			@FilteredSettingsSection(sectionName, sectionTitle, query)
		}
	</div>
}

// SettingsSection renders a single settings section
templ SettingsSection(sectionName, sectionTitle string) {
	<div class="settings-section" data-section={ sectionName }>
		<h2>{ sectionTitle }</h2>
		<div class="settings-grid">
			for _, field := range config.GetConfigFields()[sectionName] {
				@SettingField(field)
			}
		</div>
	</div>
}

// FilteredSettingsSection renders a settings section with fields filtered by search query
templ FilteredSettingsSection(sectionName, sectionTitle, query string) {
	if hasMatchingFields(sectionName, sectionTitle, query) {
		<div class="settings-section" data-section={ sectionName }>
			<h2>{ sectionTitle }</h2>
			<div class="settings-grid">
				for _, field := range config.GetConfigFields()[sectionName] {
					if fieldMatchesQuery(field, query) {
						@SettingField(field)
					}
				}
			</div>
		</div>
	}
}

// SettingField renders a single setting field
templ SettingField(field map[string]interface{}) {
	<div class="setting-item">
		<label for={ getString(field["id"]) }>{ getString(field["label"]) }</label>
		<input type="hidden" name="name" value={ getString(field["name"]) } />
		
		switch getString(field["type"]) {
			case "password":
				<input 
					type="password" 
					id={ getString(field["id"]) }
					name="value"
					value={ getString(field["value"]) }
					hx-put="/api/settings/update"
					hx-trigger="change"
					hx-include="previous input[type=hidden]"
				/>
			case "number":
				<input 
					type="number" 
					id={ getString(field["id"]) }
					name="value"
					value={ getString(field["value"]) }
					if getString(field["step"]) != "" {
						step={ getString(field["step"]) }
					}
					if getString(field["min"]) != "" {
						min={ getString(field["min"]) }
					}
					if getString(field["max"]) != "" {
						max={ getString(field["max"]) }
					}
					hx-put="/api/settings/update"
					hx-trigger="change"
					hx-include="previous input[type=hidden]"
				/>
			case "checkbox":
				<input 
					type="checkbox" 
					id={ getString(field["id"]) }
					name="value"
					if getBool(field["value"]) {
						checked
					}
					hx-put="/api/settings/update"
					hx-trigger="change"
					hx-include="previous input[type=hidden]"
				/>
			default:
				<input 
					type="text" 
					id={ getString(field["id"]) }
					name="value"
					value={ getString(field["value"]) }
					hx-put="/api/settings/update"
					hx-trigger="change"
					hx-include="previous input[type=hidden]"
				/>
		}
	</div>
}

// Helper functions
func getSectionTitles() map[string]string {
	return map[string]string{
		"stripe":   "Stripe Configuration",
		"business": "Business Information",
		"tax":      "Tax Configuration",
		"system":   "System Configuration",
		"tipping":  "Tipping Configuration",
		"sms":      "SMS Configuration",
	}
}

func getString(value interface{}) string {
	if value == nil {
		return ""
	}
	return fmt.Sprintf("%v", value)
}

func getBool(value interface{}) bool {
	if b, ok := value.(bool); ok {
		return b
	}
	return false
}

// hasMatchingFields checks if a section has any fields matching the search query
func hasMatchingFields(sectionName, sectionTitle, query string) bool {
	// Check if section title matches
	if strings.Contains(strings.ToLower(sectionTitle), query) {
		return true
	}
	
	// Check if any field in the section matches
	for _, field := range config.GetConfigFields()[sectionName] {
		if fieldMatchesQuery(field, query) {
			return true
		}
	}
	return false
}

// fieldMatchesQuery checks if a field matches the search query
func fieldMatchesQuery(field map[string]interface{}, query string) bool {
	// Check field label
	if label := getString(field["label"]); strings.Contains(strings.ToLower(label), query) {
		return true
	}
	
	// Check field name
	if name := getString(field["name"]); strings.Contains(strings.ToLower(name), query) {
		return true
	}
	
	// Check field value (convert to string)
	if value := getString(field["value"]); strings.Contains(strings.ToLower(value), query) {
		return true
	}
	
	return false
} 